using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using AutoMapper;
using Microsoft.Extensions.Options;
using RE.Core.Business.Queries.Responses.Evaluations;
using RE.Core.Configuration;
using RE.Core.Exceptions;
using RE.Core.Extensions;
using RE.Domain.Entities;
using RE.Domain.Enums;
using RE.Domain.Structs;
using FluentDateTime;

namespace RE.Core.Mappings.Converters
{
    public class EvaluationToEvaluationDtoConverter : ITypeConverter<Evaluation, EvaluationDto>
    {
        private readonly Settings _settings;
        private readonly UrlSettings _urlSettings;

        public EvaluationToEvaluationDtoConverter(Configuration.Settings settings, IOptions<UrlSettings> urlSettings)
        {
            _settings = settings;
            _urlSettings = urlSettings.Value;
        }

        public EvaluationDto Convert(Evaluation source, EvaluationDto destination, ResolutionContext context)
        {
            destination ??= new EvaluationDto();

            try
            {
                var allEvaluations = source.Offer.Evaluations.OrderBy(e => e.CapturedAt).ToList();

                destination.Amount = source.Amount;
                destination.AvailableFrom = source.CapturedAt;
                destination.AvailableTo = GetEvaluationExpiration(source, allEvaluations);
                destination.FriendlyAvailableFrom = ToFriendlyDate(source);
                destination.CaptureLink = ProvideWebShot(source.Offer, source);
                destination.Fluctuation = DiscoverPriceTrend(source, allEvaluations);
            }
            catch (Exception ex)
            {
                throw new InvalidEvaluationException(source.Id, ex);
            }

            return destination;
        }

        private DateTime GetEvaluationExpiration(Evaluation evaluation, IList<Evaluation> evaluations)
        {
            var nextEvaluation = evaluations.Next(evaluation);
            if (nextEvaluation is not null)
                return nextEvaluation.CapturedAt.PreviousDay().EndOfDay();

            var offerExpiration = evaluation.Offer.ExpiredAt;
            var endOfCurrentDay = DateTimeOffset.UtcNow.Date.EndOfDay();
            return offerExpiration?.EndOfDay() ?? endOfCurrentDay;
        }

        private string ToFriendlyDate(Evaluation source)
        {
            var isToDay = source.CapturedAt == DateTimeOffset.UtcNow.Date;
            return isToDay ? "Today" : new RelativeTime(source.CapturedAt).ToString();
        }

        private string ProvideWebShot(Offer offer, Evaluation evaluation)
        {
            var offerFilePath = Path.Combine(_settings.ScreenShotsDirectory, offer.Website.Domain, offer.Uid, $"{evaluation.Amount}.jpg");
            var file = new Uri(offerFilePath);
            if (File.Exists(file.LocalPath))
            {
                var fileSegments = file.Segments.SkipWhile(s => s != $"{_settings.GetScreenShotsEndpoint().TrimStart('/')}/");
                return $"{_urlSettings.ApplicationWebsiteBaseUrl}{string.Join(string.Empty, fileSegments)}";
            }

            return null;
        }

        private Trend DiscoverPriceTrend(Evaluation evaluation, IList<Evaluation> evaluations)
        {
            var previousEvaluation = evaluations.Previous(evaluation);
            if (previousEvaluation is not null)
            {
                if (evaluation.Amount < previousEvaluation.Amount)
                    return Trend.Descending;
                else if (evaluation.Amount > previousEvaluation.Amount)
                    return Trend.Ascending;
                return Trend.Linear;
            }

            return Trend.Linear;
        }
    }
}