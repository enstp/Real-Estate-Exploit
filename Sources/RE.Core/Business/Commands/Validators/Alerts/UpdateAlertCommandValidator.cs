using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using FluentValidation;
using Microsoft.EntityFrameworkCore;
using RE.Core.Business.Commands.Requests.Alerts;
using RE.Core.Interfaces.Repository;

namespace RE.Core.Business.Commands.Validators.Alerts
{
    public class UpdateAlertCommandValidator : AbstractValidator<UpdateAlertCommand>
    {
        private readonly IAlertRepository _alertRepo;

        public UpdateAlertCommandValidator(IAlertRepository alertRepo)
        {
            _alertRepo = alertRepo;

            RuleFor(v => v.Email).NotEmpty().DependentRules(() =>
                RuleFor(x => x.Email).MustAsync(BeUniqueEmail).WhenAsync(IsNewEmail).WithMessage("Email is already taken"));

            RuleFor(v => v.RoomTypes).Must(roomTypes => roomTypes?.Any() == true).WithMessage("At least one room number must be selected");

            RuleFor(v => v.FloorTypes).Must(floorTypes => floorTypes?.Any() == true).WithMessage("At least one floor number must be selected");

            RuleFor(v => v.PartitionTypes).Must(partitionTypes => partitionTypes?.Any() == true).WithMessage("At least one partitioning must be selected");
        }

        private async Task<bool> IsNewEmail(UpdateAlertCommand command, CancellationToken token)
        {
            var alert = await _alertRepo.Get(command.Id, token);
            var normalizedEmail = command.Email.ToUpper();
            return alert.Email.ToUpper() != normalizedEmail;
        }

        private async Task<bool> BeUniqueEmail(string email, CancellationToken token)
        {
            var normalizedEmail = email.ToUpper();
            return await _alertRepo.Query().AllAsync(a => a.Email.ToUpper() != normalizedEmail, token);
        }
    }
}
