using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace RE.Core.Extensions
{
    public static class TypeExtensions
    {
        public static bool IsAssignableFromGenericInterfaceWithParameter<TParameter>([NotNull] this Type type, Type genericType)
        {
            return type.GetInterfaces().Any(
                i =>
                    i.IsAnyTypeOf(genericType) && 
                    i.GetGenericAssignableParameter<TParameter>() is not null);
        }

        public static IEnumerable<Type> GetInterfacesWithAssignableParameter<T>([NotNull] this Type type)
        {
            return type.GetInterfacesWithAssignableParameter(typeof(T));
        }

        public static IEnumerable<Type> GetNonGenericInterfaces([NotNull] this Type type)
        {
            return type.GetInterfaces().Where(i => !i.IsGenericType);
        }

        public static IEnumerable<Type> GetInterfacesWithAssignableParameter([NotNull] this Type type, Type paramType)
        {
            return type.GetInterfaces().Where(i => i.GetGenericAssignableParameter(paramType) is not null);
        }

        public static Type GetGenericAssignableParameter<T>([NotNull] this Type type)
        {
            return type.GetGenericAssignableParameter(typeof(T));
        }

        public static Type GetGenericAssignableParameter([NotNull] this Type type, Type paramType)
        {
            return type.GetGenericArguments().FirstOrDefault(a => a.IsAnyTypeOf(paramType));
        }

        public static bool IsTypeOf<T>([NotNull]this Type type)
        {
            return  typeof(T).IsAnyTypeOf(type);
        }

        public static bool IsTypeOf([NotNull] this Type type, Type targetType)
        {
            return targetType.IsAnyTypeOf(type);
        }

        public static bool IsOneOfTypes([NotNull] this object type, params Type[] types)
        {
            return types.Any(t => type.GetType().IsTypeOf(t));
        }

        // Refer to https://stackoverflow.com/questions/4963160/how-to-determine-if-a-type-implements-an-interface-with-c-sharp-reflection
        public static bool IsAnyTypeOf([NotNull] this Type source, Type target)
        {
            return target.IsAssignableFrom(source) ||                                                              // for simple classes
                   source.IsSubclassOfRawGeneric(target) ||                                                        // for generic classes
                   source.GetInterfaces().Contains(target) ||                                                      // for simple interfaces
                   source.GetInterfaces().Any(i => i.IsGenericType && i.GetGenericTypeDefinition() == target);     // for generic interfaces
        }

        // Refer to https://stackoverflow.com/questions/457676/check-if-a-class-is-derived-from-a-generic-class
        public static bool IsSubclassOfRawGeneric([NotNull] this Type toCheck, Type baseType)
        {
            while (toCheck is not null && toCheck != typeof(object))
            {
                var cur = toCheck.IsGenericType ? toCheck.GetGenericTypeDefinition() : toCheck;
                if (baseType == cur)
                {
                    return true;
                }

                toCheck = toCheck.BaseType;
            }

            return false;
        }

        public static T Convert<T>(this string input)
        {
            try
            {
                var converter = TypeDescriptor.GetConverter(typeof(T));
                return (T)converter.ConvertFromString(input);
            }
            catch (Exception)
            {
                return default(T);
            }
        }

        public static T GetValueOr<T>(this T? value, T defaultValue) where T : struct, IComparable
        {
            return value ?? defaultValue;
        }
    }
}
