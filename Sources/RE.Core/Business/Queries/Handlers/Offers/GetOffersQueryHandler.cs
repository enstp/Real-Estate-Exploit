using System;
using System.Linq;
using System.Linq.Expressions;
using System.Threading;
using System.Threading.Tasks;
using AutoMapper;
using AutoMapper.QueryableExtensions;
using Microsoft.EntityFrameworkCore;
using RE.Core.Business.Base.Handlers;
using RE.Core.Business.Queries.Requests.Offers;
using RE.Core.Business.Queries.Responses.Offers;
using RE.Core.Extensions;
using RE.Core.Interfaces.Repository;
using RE.Core.Models.Filters;
using RE.Core.Models.Inclusions;
using RE.Core.Models.Pagination;
using RE.Domain.Constants;
using RE.Domain.Enums;

namespace RE.Core.Business.Queries.Handlers.Offers
{
    public class GetOffersQueryHandler : BaseHandler<GetOffersQuery, OfferViewModel>
    {
        private readonly IOfferRepository _offerRepo;
        private readonly IMapper _mapper;

        public GetOffersQueryHandler(IOfferRepository offerRepo, IMapper mapper)
        {
            _offerRepo = offerRepo;
            _mapper = mapper;
        }

        public override async Task<OfferViewModel> HandleRequest(GetOffersQuery request, CancellationToken cancellationToken)
        {
            var inclusions = new OfferInclusions { IncludeWebsite = true, IncludeEvaluations = true };
            var offersQuery = _offerRepo.QueryForWebsite(request.WebsiteId, inclusions)
                .ProjectTo<OfferDto>(_mapper.ConfigurationProvider);
            offersQuery = Filter(offersQuery, request.SearchInfo, request.FilterInfo);
            offersQuery = Sort(offersQuery, request.SortInfo);

            var totalCount = await offersQuery.CountAsync(cancellationToken);
            var offers = await offersQuery.Paged(request.PagingInfo).ToListAsync(cancellationToken);

            return new OfferViewModel
            {
                Offers = new PagedList<OfferDto>(offers, request.PagingInfo, totalCount),
                Search = request.SearchInfo,
                Sort = request.SortInfo,
                Filter = request.FilterInfo,

                Websites = request.Items,
                AuthorizedAccess = request.AuthorizedAccess
            };
        }

        private IQueryable<OfferDto> Filter(IQueryable<OfferDto> query, SearchInfo search, FilterInfo filter)
        {
            if (!string.IsNullOrWhiteSpace(search.Q))
            {
                // Filter by Search Term
                query = query.Where(x => x.Uid.ToLower().Contains(search.Q.ToLower().Trim()) ||
                                         x.Title.ToLower().Contains(search.Q.ToLower().Trim()) ||
                                         x.Url.ToLower().Contains(search.Q.ToLower().Trim()));
            }

            // Filter by Active
            if(filter.AvailabilityType != AvailabilityFilter.All)
                query = query.Where(o => o.Active == (filter.AvailabilityType == AvailabilityFilter.Active));

            // Filter by Rooms No
            var rooms = filter.RoomTypes.Select(r => (short) r).ToList();
            query = query.Where(o => rooms.Contains(o.Rooms) || (rooms.Contains(4) && o.Rooms > 4 ? true : false));

            // Filter by Floor No
            var floors = filter.FloorTypes.Select(f => (short)f).ToList();
            query = query.Where(o => floors.Contains(o.Floor ?? Numerics.Unspecified) || (floors.Contains(10) && (o.Floor ?? Numerics.Unspecified) > 10 ? true : false));

            // Filter by Trend
            if(!string.IsNullOrEmpty(filter.TrendType))
                query = query.Where(o => o.Trend == filter.TrendType.ParseEnum<Trend>());

            // Filter by Publish Date
            if (filter.PublishDateFrom.HasValue)
                query = query.Where(o => o.PublishDate >= filter.PublishDateFrom.Value.Date);
            if (filter.PublishDateTo.HasValue)
                query = query.Where(o => o.PublishDate <= filter.PublishDateTo.Value.Date.AddHours(23).AddMinutes(59).AddSeconds(59));

            return query;
        }

        private IQueryable<OfferDto> Sort(IQueryable<OfferDto> query, SortInfo info)
        {
            Expression<Func<OfferDto, decimal>> priceExpr = o => o.Price;
            Expression<Func<OfferDto, DateTime>> captureExpr = o => o.PublishDate;
            Expression<Func<OfferDto, int>> evaluationExpr = o => o.Evaluations;
            return info.SortFieldName switch
            {
                SortFields.Price => info.SortDirection == SortDirection.Ascending ? query.OrderBy(priceExpr) : query.OrderByDescending(priceExpr),
                SortFields.PublishDate => info.SortDirection == SortDirection.Ascending ? query.OrderBy(captureExpr) : query.OrderByDescending(captureExpr),
                SortFields.Evaluations => info.SortDirection == SortDirection.Ascending ? query.OrderBy(evaluationExpr) : query.OrderByDescending(evaluationExpr),
                _ => query
            };
        }
    }
}