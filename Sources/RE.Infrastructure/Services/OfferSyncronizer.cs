using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using MediatR;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using RE.Core.Extensions;
using RE.Core.Interfaces;
using RE.Core.Interfaces.Services;
using RE.Core.Models.Scrapper;
using RE.Domain.Entities;
using RE.Domain.ValueObjects;

namespace RE.Infrastructure.Services
{
    public class OfferSyncronizer : IOfferSyncronizer
    {
        private readonly IApplicationDbContext _dbContext;
        private readonly IDateTimeService _dateTimeService;
        private readonly IMediator _mediator;
        private readonly ILogger<ScrapperService> _logger;

        public OfferSyncronizer(
            IApplicationDbContext dbContext,
            IDateTimeService dateTimeService,
            IMediator mediator,
            ILogger<ScrapperService> logger)
        {
            _dbContext = dbContext;
            _dateTimeService = dateTimeService;
            _mediator = mediator;
            _logger = logger;
        }

        public async Task<IList<Offer>> Sync(IList<Ad> offers, CancellationToken cancellationToken = default)
        {
            var domains = offers.GroupBy(o => o.Host);
            var updatedOffers = new List<Offer>();
            foreach (var domain in domains)
            {
                var website = await _dbContext.Websites
                    .Include(w => w.Offers).ThenInclude(o => o.Evaluations)
                    .AsSplitQuery()
                    .OrderBy(o => o.Domain)
                    .SingleAsync(o => o.Domain == domain.Key, cancellationToken);

                updatedOffers.AddRange(ProcessWebsiteOffers(website, domain.ToList()));
            }

            await _dbContext.SaveChangesAsync(cancellationToken);
            return updatedOffers;
        }

        public async Task UnSync(IList<Offer> offers, CancellationToken cancellationToken = default)
        {
            foreach (var offer in offers)
            {
                offer.ExpiredAt = DateTimeOffset.Now.Date;
            }

            await _dbContext.SaveChangesAsync(cancellationToken);
        }

        private IEnumerable<Offer> ProcessWebsiteOffers(Website website, IList<Ad> offers)
        {
            foreach (var offerDto in offers)
            {
                var offer = website.Offers.FirstOrDefault(o => o.Uid == offerDto.Sku);
                offer ??= _dbContext.Offers.Add(CreateOffer(offerDto, website.Id)).Entity;

                if (offer.Id == 0)
                {
                    // New offer
                    yield return offer;
                }
                else if (offer.Evaluations.MostRecent().Amount != offerDto.Price)
                {
                    // New quotation
                    offer.Evaluations.Add(CreateQuotation(offerDto, offer));
                    yield return offer;
                }
            }
        }

        private Offer CreateOffer(Ad ad, int websiteId)
        {
            var offer = new Offer
            {
                WebsiteId = websiteId,
                Uid = ad.Sku,
                Url = ad.Url.ToString(),
                Title = ad.Title,
                Rooms = ad.Rooms,
                Floor = ad.Floor,
                Year = ad.Year,
                Partitioning = ad.Partitioning,
                Area = Area.For(ad.UsableArea, ad.TotalArea),
                PublishedAt = ad.PublishDate?.Date ?? DateTimeOffset.Now.Date,
                ExpiredAt = default
            };
            offer.Evaluations.Add(CreateQuotation(ad, offer));

            return offer;
        }

        private Evaluation CreateQuotation(Ad offerDto, Offer offer)
        {
            var isNewOffer = offer.Id == 0;
            return new Evaluation
            {
                Offer = offer,
                Amount = offerDto.Price,
                CapturedAt = isNewOffer ? offer.PublishedAt : _dateTimeService.Now.Date
            };
        }
    }
}